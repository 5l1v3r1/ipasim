% !TEX encoding = UTF-8 Unicode

\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[czech]{babel}
\usepackage[left=2cm, right=2cm, top=3cm, bottom=3cm]{geometry}
\usepackage[fleqn]{mathtools}
\usepackage{amsfonts,amssymb}
\usepackage{enumitem}
\usepackage{icomma}
\usepackage{tikz}
\usepackage{etoolbox}
\usepackage{forest}
\usepackage{amsthm}
\usepackage[hidelinks]{hyperref}
\usepackage{url}
\usepackage{relsize,xspace}

% Hlavička.
\usepackage{fancyhdr}
\pagestyle{fancy}
\rhead{Jan Joneš}
\lhead{}
\renewcommand{\headrulewidth}{0pt}

% Styl URL.
\DeclareUrlCommand\url{\urlstyle{tt}}

% C++.
\newcommand{\Rplus}{\protect\hspace{-.1em}\protect\raisebox{.35ex}{\smaller{\smaller\textbf{+}}}}
\newcommand{\Cpp}{\mbox{C\Rplus\Rplus}\xspace}

% IEEE citace.
\makeatletter
\def\bstctlcite{\@ifnextchar[{\@bstctlcite}{\@bstctlcite[@auxout]}}
\def\@bstctlcite[#1]#2{\@bsphack
  \@for\@citeb:=#2\do{%
    \edef\@citeb{\expandafter\@firstofone\@citeb}%
    \if@filesw\immediate\write\csname #1\endcsname{\string\citation{\@citeb}}\fi}%
  \@esphack}
\makeatother

\begin{document}

\bstctlcite{BSTcontrol}

\section*{Specifikace programu ipaSim}

\subsection*{Úvod}

ipaSim bude program umožňující spouštět aplikace napsané pro operační systém iOS na zařízeních s operačním systémem Windows.

Vstupem bude balíček *.ipa, což je standardní formát pro distribuci aplikací na iOS a macOS.
Uvnitř balíčku je mimo jiné také strojový kód aplikace, většinou pro architekturu ARM, na které operační systém iOS běží.
Tento strojový kód bude ipaSim emulovat a funkce iOS, které bude emulovaná aplikace volat, se přeloží na odpovídající funkce Windows.

Díky tomu se bude emulovaná aplikace chovat jako nativní aplikace napsaná pro Windows.
Zároveň nebude nutné emulovat žádnou část systému iOS, pouze kód aplikace.

\subsection*{Podobné projekty}

Wine~\cite{wine} je linuxový nástroj, který umožňuje spouštět Windows aplikace.
K tomu využívá převod mezi Win32 API (tedy funkcemi operačního systému Windows) a funkcemi Linuxu, podobně jako to bude dělat naše aplikace.

Darling~\cite{darling} je velice podobný program, který umožňuje spouštění macOS aplikací na Linuxu.
Tento projekt je ovšem ve velmi rané fázi a umí emulovat pouze jednoduché konzolové aplikace \cite{darlingStatus}.

\subsection*{Platforma}

ipaSim bude UWP\footnote{\url{https://docs.microsoft.com/en-us/windows/uwp/}} aplikace napsaná v jazyce \Cpp pomocí nadstavby \Cpp/WinRT\footnote{\url{https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/}}.
To je sada hlavičkových souborů obalujících WinRT API (moderní rozhraní Windows dostupné na všech zařízeních s Windows 10 -- desktopech, mobilních zařízeních a dalších).
Jazyk \Cpp je vhodný, protože knihovny, které budeme používat, v podstatě nemají obdoby v jiných programovacích jazycích.
Zároveň bude ipaSim velice nízkoúrovňová aplikace pracující často přímo s pamětí, na což je také jazyk \Cpp ideální.
Založit projekt na platformě UWP je nutné, protože stěžejní knihovna WinObjC (viz sekci~\nameref{sec:winobjc}) je na ní založená.

\subsection*{Načítání balíčků}

Při přeložení aplikace napsané pro iOS (například pomocí IDE Xcode\footnote{\url{https://developer.apple.com/xcode/}}) vznikne balíček obsahující všechny potřebné soubory k běhu aplikace na cílovém zařízení.
Tento balíček má většinou příponu \texttt{*.ipa} (zkratka z \textit{iPhone application}), je to normální archiv ZIP a obsahuje metadata, multimediální zdroje (ikony, obrázky apod.) a samotný spustitelný soubor \cite{ipa}.
Nás bude zajímat hlavně posledně zmíněná část -- spustitelný soubor, který ipaSim musí načíst do paměti pro emulování.
Tento soubor má formát Mach-O, případně Fat Mach-O, který obsahuje více Mach-O částí pro různé architektury (např. ARM a ARM64) \cite{macho}.

Mach-O formát je podobný jiným formátům spustitelných souborů (např. PE a ELF).
Obsahuje hlavičku popisující jeho strukturu, tabulku symbolů, použité sdílené knihovny a v neposlední řadě i segmenty a sekce obsahující kód a data.
My na jeho čtení můžeme použít například knihovnu LIEF\footnote{\url{https://github.com/lief-project/LIEF}}.

Pro emulaci aplikací budeme napodobovat chování systému iOS při načítání aplikací do paměti \cite{execMacho}.
Nejprve jednoduše načteme všechny sekce obsažené v Mach-O souboru do operační paměti.
Poté provedeme relokace a dynamické linkování s knihovnami operačního systému.
Zde se právě provede převod mezi funkcemi iOS a Windows -- emulovaná aplikace totiž samozřejmě závisí na funkcích iOS, my ji ale slinkujeme s funkcemi knihovny WinObjC (viz sekci~\nameref{sec:winobjc}).

\subsection*{Emulování kódu}

Pro emulování kódu použijeme knihovnu Unicorn\footnote{\url{https://www.unicorn-engine.org/}}, která je založená na emulátoru QEMU\footnote{\url{https://www.qemu.org/}} (na rozdíl od něj ale nevyžaduje emulování celého operačního systému).
Tomuto emulátoru prostě řekneme, kde je v paměti načtený strojový kód a odkud jej má začít provádět.
Pokud emulovaná aplikace zavolá funkci iOS, vyskočí ven z namapované paměti, což zachytíme a volání převedeme na volání Windows.

\subsection*{Volání OS}
\label{sec:winobjc}

Pro převádění mezi voláními iOS a Windows použijeme knihovnu WinObjC\footnote{\url{https://github.com/Microsoft/WinObjC}}.
Ta poskytuje rozhraní přesně stejné jako systémové knihovny iOS a toto rozhraní je implementované skrze funkce WinRT a platformu UWP \cite{winobjc}.
My tedy pouze přesměrujeme volání iOS z emulované aplikace do těchto nativních funkcí.

Malý zádrhel je pouze v tom, že knihovna WinObjC je navržená pro fungování se zdrojovými kódy iOS aplikací, kdežto my chceme emulovat již přeložené spustitelné soubory.
Problém spočívá v použití běhového prostředí jazyka Objective-C, které není binárně kompatibilní s tím, které používá Apple v systému iOS.
To není problém pro WinObjC, kde se zdrojové kódy prostě přeloží pro to správné běhové prostředí, ale je to problém pro naši aplikaci, kde jsou kódy už přeložené pro konkrétní a nekompatibilní běhové prostředí.

\subsection*{Běhové prostředí jazyka Objective-C}

Aplikace pro iOS jsou napsané v jazyce Objective-C, který je velmi dynamický a pro běh programů v něm napsaných se spoléhá na svoji běhovou knihovnu, jejíž funkce přeložené programy volají \cite{objc, understandingObjc}.
Tyto funkce zahrnují například funkce pro posílání zpráv mezi objekty, což je základní forma komunikace mezi objekty v Objective-C (nahrazuje volání funkcí), nebo funkce pro dynamickou introspekci objektů, počítání referencí a další.
Zároveň se běhová knihovna spoléhá na datové struktury vygenerované překladačem, které jsou uloženy v Mach-O souboru.
Ty obsahují například informace o třídách a metodách použitých v programu a používají se například právě pro vyhledávání kódu metody při posílání zpráv mezi objekty.
A právě tyto datové struktury nejsou mezi jednotlivými běhovými knihovnami kompatibilní.
Proto je nutné použít běhovou knihovnu, která bude tyto struktury interpretovat správně, tak jak by to dělalo běhové prostředí v iOS.

Pro Windows existují různé implementace běhového prostředí jazyka Objective-C (například~\cite{modernObjc, gnustep}), žádná ale není kompatibilní s běhovým prostředím od Applu.
Proto bude naše aplikace obsahovat vlastní běhové prostředí, které bude pravděpodobně pouze port běhové knihovny od Applu.
Ta je open-source\footnote{\url{https://opensource.apple.com/source/objc4/}} a napsaná v \Cpp, takže můžeme přenositelné části zachovat a přepsat pouze kód závislý na OS.
Využijeme také, že tato knihovna používá posixová vlákna, pro které existuje na Windows port pthreads-win32\footnote{\url{http://www.sourceware.org/pthreads-win32/}}.

\bibliographystyle{IEEEtran}
\bibliography{spec}

\end{document}
